// This code was autogenerated with `dbus-codegen-rust `, see https://github.com/diwic/dbus-rs
use dbus as dbus;
use dbus::arg;
use dbus::tree;

pub trait OrgFreedesktopSecretService {
    fn open_session(&self, algorithm: &str, input: arg::Variant<Box<dyn arg::RefArg>>) -> Result<(arg::Variant<Box<dyn arg::RefArg + 'static>>, dbus::Path<'static>), tree::MethodErr>;
    fn create_collection(&self, properties: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>, alias: &str) -> Result<(dbus::Path<'static>, dbus::Path<'static>), tree::MethodErr>;
    fn search_items(&self, attributes: ::std::collections::HashMap<&str, &str>) -> Result<(Vec<dbus::Path<'static>>, Vec<dbus::Path<'static>>), tree::MethodErr>;
    fn unlock(&self, objects: Vec<dbus::Path>) -> Result<(Vec<dbus::Path<'static>>, dbus::Path<'static>), tree::MethodErr>;
    fn lock(&self, objects: Vec<dbus::Path>) -> Result<(Vec<dbus::Path<'static>>, dbus::Path<'static>), tree::MethodErr>;
    fn get_secrets(&self, items: Vec<dbus::Path>, session: dbus::Path) -> Result<::std::collections::HashMap<dbus::Path<'static>, (dbus::Path<'static>, Vec<u8>, Vec<u8>, String)>, tree::MethodErr>;
    fn read_alias(&self, name: &str) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn set_alias(&self, name: &str, collection: dbus::Path) -> Result<(), tree::MethodErr>;
    fn collections(&self) -> Result<Vec<dbus::Path<'static>>, tree::MethodErr>;
}

pub fn org_freedesktop_secret_service_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    D::Signal: Default,
    T: OrgFreedesktopSecretService,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.Secret.Service", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let algorithm: &str = i.read()?;
        let input: arg::Variant<Box<dyn arg::RefArg>> = i.read()?;
        let d = fclone(minfo);
        let (output, result) = d.open_session(algorithm, input)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(output);
        let rm = rm.append1(result);
        Ok(vec!(rm))
    };
    let m = factory.method("OpenSession", Default::default(), h);
    let m = m.in_arg(("algorithm", "s"));
    let m = m.in_arg(("input", "v"));
    let m = m.out_arg(("output", "v"));
    let m = m.out_arg(("result", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let properties: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>> = i.read()?;
        let alias: &str = i.read()?;
        let d = fclone(minfo);
        let (collection, prompt) = d.create_collection(properties, alias)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(collection);
        let rm = rm.append1(prompt);
        Ok(vec!(rm))
    };
    let m = factory.method("CreateCollection", Default::default(), h);
    let m = m.in_arg(("properties", "a{sv}"));
    let m = m.in_arg(("alias", "s"));
    let m = m.out_arg(("collection", "o"));
    let m = m.out_arg(("prompt", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let attributes: ::std::collections::HashMap<&str, &str> = i.read()?;
        let d = fclone(minfo);
        let (unlocked, locked) = d.search_items(attributes)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unlocked);
        let rm = rm.append1(locked);
        Ok(vec!(rm))
    };
    let m = factory.method("SearchItems", Default::default(), h);
    let m = m.in_arg(("attributes", "a{ss}"));
    let m = m.out_arg(("unlocked", "ao"));
    let m = m.out_arg(("locked", "ao"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let objects: Vec<dbus::Path> = i.read()?;
        let d = fclone(minfo);
        let (unlocked, prompt) = d.unlock(objects)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(unlocked);
        let rm = rm.append1(prompt);
        Ok(vec!(rm))
    };
    let m = factory.method("Unlock", Default::default(), h);
    let m = m.in_arg(("objects", "ao"));
    let m = m.out_arg(("unlocked", "ao"));
    let m = m.out_arg(("prompt", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let objects: Vec<dbus::Path> = i.read()?;
        let d = fclone(minfo);
        let (locked, prompt) = d.lock(objects)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(locked);
        let rm = rm.append1(prompt);
        Ok(vec!(rm))
    };
    let m = factory.method("Lock", Default::default(), h);
    let m = m.in_arg(("objects", "ao"));
    let m = m.out_arg(("locked", "ao"));
    let m = m.out_arg(("Prompt", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let items: Vec<dbus::Path> = i.read()?;
        let session: dbus::Path = i.read()?;
        let d = fclone(minfo);
        let secrets = d.get_secrets(items, session)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(secrets);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSecrets", Default::default(), h);
    let m = m.in_arg(("items", "ao"));
    let m = m.in_arg(("session", "o"));
    let m = m.out_arg(("secrets", "a{o(oayays)}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let d = fclone(minfo);
        let collection = d.read_alias(name)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(collection);
        Ok(vec!(rm))
    };
    let m = factory.method("ReadAlias", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.out_arg(("collection", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = i.read()?;
        let collection: dbus::Path = i.read()?;
        let d = fclone(minfo);
        d.set_alias(name, collection)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetAlias", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.in_arg(("collection", "o"));
    let i = i.add_m(m);

    let p = factory.property::<Vec<dbus::Path>, _>("Collections", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.collections()?);
        Ok(())
    });
    let i = i.add_p(p);
    let s = factory.signal("CollectionCreated", Default::default());
    let s = s.arg(("collection", "o"));
    let i = i.add_s(s);
    let s = factory.signal("CollectionDeleted", Default::default());
    let s = s.arg(("collection", "o"));
    let i = i.add_s(s);
    let s = factory.signal("CollectionChanged", Default::default());
    let s = s.arg(("collection", "o"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionCreated {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionCreated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionCreated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionCreated {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionCreated {
    const NAME: &'static str = "CollectionCreated";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionDeleted {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionDeleted {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionDeleted {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionDeleted {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionDeleted {
    const NAME: &'static str = "CollectionDeleted";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretServiceCollectionChanged {
    pub collection: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretServiceCollectionChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.collection, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretServiceCollectionChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretServiceCollectionChanged {
            collection: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretServiceCollectionChanged {
    const NAME: &'static str = "CollectionChanged";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Service";
}

pub trait OrgFreedesktopSecretCollection {
    fn delete(&self) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn search_items(&self, attributes: ::std::collections::HashMap<&str, &str>) -> Result<Vec<dbus::Path<'static>>, tree::MethodErr>;
    fn create_item(&self, properties: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>>, secret: (dbus::Path, Vec<u8>, Vec<u8>, &str), replace: bool) -> Result<(dbus::Path<'static>, dbus::Path<'static>), tree::MethodErr>;
    fn items(&self) -> Result<Vec<dbus::Path<'static>>, tree::MethodErr>;
    fn label(&self) -> Result<String, tree::MethodErr>;
    fn set_label(&self, value: String) -> Result<(), tree::MethodErr>;
    fn locked(&self) -> Result<bool, tree::MethodErr>;
    fn created(&self) -> Result<u64, tree::MethodErr>;
    fn modified(&self) -> Result<u64, tree::MethodErr>;
}

pub fn org_freedesktop_secret_collection_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    D::Signal: Default,
    T: OrgFreedesktopSecretCollection,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.Secret.Collection", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let prompt = d.delete()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(prompt);
        Ok(vec!(rm))
    };
    let m = factory.method("Delete", Default::default(), h);
    let m = m.out_arg(("prompt", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let attributes: ::std::collections::HashMap<&str, &str> = i.read()?;
        let d = fclone(minfo);
        let results = d.search_items(attributes)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(results);
        Ok(vec!(rm))
    };
    let m = factory.method("SearchItems", Default::default(), h);
    let m = m.in_arg(("attributes", "a{ss}"));
    let m = m.out_arg(("results", "ao"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let properties: ::std::collections::HashMap<&str, arg::Variant<Box<dyn arg::RefArg>>> = i.read()?;
        let secret: (dbus::Path, Vec<u8>, Vec<u8>, &str) = i.read()?;
        let replace: bool = i.read()?;
        let d = fclone(minfo);
        let (item, prompt) = d.create_item(properties, secret, replace)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(item);
        let rm = rm.append1(prompt);
        Ok(vec!(rm))
    };
    let m = factory.method("CreateItem", Default::default(), h);
    let m = m.in_arg(("properties", "a{sv}"));
    let m = m.in_arg(("secret", "(oayays)"));
    let m = m.in_arg(("replace", "b"));
    let m = m.out_arg(("item", "o"));
    let m = m.out_arg(("prompt", "o"));
    let i = i.add_m(m);

    let p = factory.property::<Vec<dbus::Path>, _>("Items", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.items()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Label", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.label()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_label(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Locked", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.locked()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("Created", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.created()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("Modified", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.modified()?);
        Ok(())
    });
    let i = i.add_p(p);
    let s = factory.signal("ItemCreated", Default::default());
    let s = s.arg(("item", "o"));
    let i = i.add_s(s);
    let s = factory.signal("ItemDeleted", Default::default());
    let s = s.arg(("item", "o"));
    let i = i.add_s(s);
    let s = factory.signal("ItemChanged", Default::default());
    let s = s.arg(("item", "o"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretCollectionItemCreated {
    pub item: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretCollectionItemCreated {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.item, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretCollectionItemCreated {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretCollectionItemCreated {
            item: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretCollectionItemCreated {
    const NAME: &'static str = "ItemCreated";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Collection";
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretCollectionItemDeleted {
    pub item: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretCollectionItemDeleted {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.item, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretCollectionItemDeleted {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretCollectionItemDeleted {
            item: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretCollectionItemDeleted {
    const NAME: &'static str = "ItemDeleted";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Collection";
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretCollectionItemChanged {
    pub item: dbus::Path<'static>,
}

impl arg::AppendAll for OrgFreedesktopSecretCollectionItemChanged {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.item, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretCollectionItemChanged {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretCollectionItemChanged {
            item: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretCollectionItemChanged {
    const NAME: &'static str = "ItemChanged";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Collection";
}

pub trait OrgFreedesktopSecretItem {
    fn delete(&self) -> Result<dbus::Path<'static>, tree::MethodErr>;
    fn get_secret(&self, session: dbus::Path) -> Result<(dbus::Path<'static>, Vec<u8>, Vec<u8>, String), tree::MethodErr>;
    fn set_secret(&self, secret: (dbus::Path, Vec<u8>, Vec<u8>, &str)) -> Result<(), tree::MethodErr>;
    fn locked(&self) -> Result<bool, tree::MethodErr>;
    fn attributes(&self) -> Result<::std::collections::HashMap<String, String>, tree::MethodErr>;
    fn set_attributes(&self, value: ::std::collections::HashMap<String, String>) -> Result<(), tree::MethodErr>;
    fn label(&self) -> Result<String, tree::MethodErr>;
    fn set_label(&self, value: String) -> Result<(), tree::MethodErr>;
    fn created(&self) -> Result<u64, tree::MethodErr>;
    fn modified(&self) -> Result<u64, tree::MethodErr>;
}

pub fn org_freedesktop_secret_item_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgFreedesktopSecretItem,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.Secret.Item", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let prompt = d.delete()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(prompt);
        Ok(vec!(rm))
    };
    let m = factory.method("Delete", Default::default(), h);
    let m = m.out_arg(("Prompt", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let session: dbus::Path = i.read()?;
        let d = fclone(minfo);
        let secret = d.get_secret(session)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(secret);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSecret", Default::default(), h);
    let m = m.in_arg(("session", "o"));
    let m = m.out_arg(("secret", "(oayays)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let secret: (dbus::Path, Vec<u8>, Vec<u8>, &str) = i.read()?;
        let d = fclone(minfo);
        d.set_secret(secret)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetSecret", Default::default(), h);
    let m = m.in_arg(("secret", "(oayays)"));
    let i = i.add_m(m);

    let p = factory.property::<bool, _>("Locked", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.locked()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<::std::collections::HashMap<&str, &str>, _>("Attributes", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.attributes()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_attributes(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Label", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.label()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_label(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("Created", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.created()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("Modified", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.modified()?);
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgFreedesktopSecretSession {
    fn close(&self) -> Result<(), tree::MethodErr>;
}

pub fn org_freedesktop_secret_session_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopSecretSession,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.Secret.Session", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.close()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Close", Default::default(), h);
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopSecretPrompt {
    fn prompt(&self, window_id: &str) -> Result<(), tree::MethodErr>;
    fn dismiss(&self) -> Result<(), tree::MethodErr>;
}

pub fn org_freedesktop_secret_prompt_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Signal: Default,
    T: OrgFreedesktopSecretPrompt,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.Secret.Prompt", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let window_id: &str = i.read()?;
        let d = fclone(minfo);
        d.prompt(window_id)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Prompt", Default::default(), h);
    let m = m.in_arg(("window-id", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.dismiss()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Dismiss", Default::default(), h);
    let i = i.add_m(m);
    let s = factory.signal("Completed", Default::default());
    let s = s.arg(("dismissed", "b"));
    let s = s.arg(("result", "v"));
    let i = i.add_s(s);
    i
}

#[derive(Debug)]
pub struct OrgFreedesktopSecretPromptCompleted {
    pub dismissed: bool,
    pub result: arg::Variant<Box<dyn arg::RefArg + 'static>>,
}

impl arg::AppendAll for OrgFreedesktopSecretPromptCompleted {
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.dismissed, i);
        arg::RefArg::append(&self.result, i);
    }
}

impl arg::ReadAll for OrgFreedesktopSecretPromptCompleted {
    fn read(i: &mut arg::Iter) -> Result<Self, arg::TypeMismatchError> {
        Ok(OrgFreedesktopSecretPromptCompleted {
            dismissed: i.read()?,
            result: i.read()?,
        })
    }
}

impl dbus::message::SignalArgs for OrgFreedesktopSecretPromptCompleted {
    const NAME: &'static str = "Completed";
    const INTERFACE: &'static str = "org.freedesktop.Secret.Prompt";
}
